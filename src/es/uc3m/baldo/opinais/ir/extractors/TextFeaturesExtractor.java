package es.uc3m.baldo.opinais.ir.extractors;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Pattern;

import es.uc3m.baldo.opinais.core.Type;
import es.uc3m.baldo.opinais.ir.items.TextItem;

/**
 * <p>Extracts string features from a set of text items based on the information
 * gain measure.</p>
 * <p>In summary, it calculates the information gain for each word
 * in the text, selecting as features the <em>n</em> words with a higher value
 * for this metric.</p>
 * <p>In a later stage, items are vectorized into an array of bits, with each 
 * of these representing whether the item contains the word in the same position
 * in the features array.</p>
 * 
 * @see es.uc3m.baldo.opinais.ir.vectorizers.TextVectorizer
 * 
 * @author Alejandro Baldominos
 */
public class TextFeaturesExtractor implements FeaturesExtractor<String, TextItem> {
	
	/* 
	 * Text separator, usually one or more empty spaces.
	 * It is compiled for efficiency purposes.
	 */
	private static final Pattern SEPARATOR = Pattern.compile(" +");
	
	/* 
	 * The number of features to be extracted from the set of
	 * text items.
	 */
	private int nFeatures;
	
	/**
	 * <p>Constructs a new text features extractor.</p>
	 * @param nFeatures the number of features to be extracted 
	 * from the set of text items.
	 */
	public TextFeaturesExtractor (int nFeatures) {
		this.nFeatures = nFeatures;
	}
	
	/**
	 * <p>Extracts string features from a set of text items based on the information
	 * gain measure.</p>
	 * <p>In summary, it calculates the information gain for each word
	 * in the text, selecting as features the <em>n</em> words with a higher value
	 * for this metric.</p>
	 * @param the set of items needed to extract the features.
	 * @return a sorted array of string containing the features (words).
	 */
	@Override
	public String[] extractFeatures (Set<? extends TextItem> items) {
		// Stores the sorted list of features to be extracted.		
		String[] features = new String[nFeatures];
		
		// Stores the set of all possible words.
		Set<String> words = new HashSet<String>();
		
		// Stores the global count of occurrences for each type,
		// i.e., the number of items belonging to each specific type.
		Map<Type, Integer> occurrences = new HashMap<Type, Integer>();
		for (Type type : Type.values()) {
			occurrences.put(type, 0);
		}
		
		// Stores the number of occurrences for each word and type.
		Map<Type, Map<String, Integer>> wordsOccurrencesByType = new HashMap<Type, Map<String, Integer>>();
		for (Type type : Type.values()) {
			wordsOccurrencesByType.put(type, new HashMap<String, Integer>());
		}
		
		// Iterates over all items to count the words occurrences.
		System.out.println("\tCounting words occurrences...");		
		for (TextItem item : items) {
			// Adds the item's type to the global count.
			occurrences.put(item.getType(), occurrences.get(item.getType()) + 1);
			
			// Stores the number of words already counted for this item
			// (to prevent from double-counting).
			Set<String> presentInItem = new HashSet<String>();
			
			// Splits the text into words and iterates over them.
			for (String word : SEPARATOR.split(item.getText())) {
				// Removes "empty" words and double-counting by checking
				// whether this word was already counted for this item.
				if (!word.isEmpty()&& !presentInItem.contains(word)) {
					// Adds the word to the set of words.
					// Because of the chosen data structure, duplicates
					// are ignored.
					words.add(word);
					
					// Adds the word to the occurrences count per type.
					Map<String, Integer> wordsOccurrences = wordsOccurrencesByType.get(item.getType());
					if (wordsOccurrences.containsKey(word)) {
						wordsOccurrences.put(word, wordsOccurrences.get(word) + 1);
					} else {
						// Notice that map entries are added only when required.
						// This is done to prevent from taking unneccessary storage.
						wordsOccurrences.put(word, 1);
					}
					
					// Marks the word as already counted by adding
					// it to the set.
					presentInItem.add(word);
				}
			}
		}
		
		System.out.println("\tCalculating information gains for each word...");
		// Stores all the features generated by the text items.
		// The choice of a TreeSet as the data structure enables ordering.
		Set<Feature<String>> valuedFeatures = new TreeSet<Feature<String>>(); 
		
		// Calculates the total number of items.
		int size = items.size();
		
		// Calculates the information gain for the set of items.
		double ig = informationGain(items);
		
		// Iterates over each word.
		for (String word : words) {	
			// Calculates the percentage of appearance
			// for the specific word.
			double pctAppearance = 0;
			for (Map<String, Integer> map : wordsOccurrencesByType.values()) {
				if (map.containsKey(word)) {
					pctAppearance += map.get(word);
				}
			}
			pctAppearance /= size;
			
			// Calculates the entropy of the word, based on the information 
			// gain of both its appearance and lack of appearance.
			double entropy = ig - pctAppearance * informationGain(word, occurrences, wordsOccurrencesByType, true)
								- (1 - pctAppearance) * informationGain(word, occurrences, wordsOccurrencesByType, false);
			
			// Adds the new feature to the sorted set.
			valuedFeatures.add(new Feature<String>(word, entropy));
		}
		
		System.out.println("\tExtracting most relevant features...");
		// Extracts the n most relevant features.
		int i = 0;
		for (Feature<String> feature : valuedFeatures) {
			if (i >= nFeatures) {
				break;
			}
			features[i] = feature.getValue();
			i++;
		}

		return features;
	}
	
	/**
	 * <p>Calculates the information gain from a subset of items.</p>
	 * <p>This method is implemented for efficiency purposes: while 
	 * {@link TextFeaturesExtractor#extractFeatures(Set)} could be
	 * used instead, creating a set of items containing (or not containing)
	 * an specific word is quite time-expensive.</p>
	 * <p>This alternative uses frequency maps for each word and type, which 
	 * provides all the information required for calculating the information
	 * gain without the explicit requirement of creating two sets for each word.
	 * By doing so, the time required for features extraction is reduced in several
	 * orders of magnitude.</p>
	 * <p>The information gain is calculated as I\(S^{word}\) = \sum_{t \in Types}
	 * {P\(S_t^{word}\)\log_{2}{P\(S_t^{word}\)}}, where P\(S_t^{word}\) means
	 * the probability that an item either containing or not (depending on the
	 * value of the <em>appears</em> flag) an specific word belongs to the type
	 * <em>t</em>.</p>
	 * @param word the specific word to calculate the information gain.
	 * @param occurrences a map containing the number of items per each type.
	 * @param wordsOccurrences a map containing the number of occurrences of each
	 * word per each type.
	 * @param appears determines whether to calculate the information gain over the
	 * appearance set (true) or the non-appearance set (false).
	 * @return the information gain for the appearance (or lack of appearance if
	 * the <em>appears</em> flag is set to false) of the specified word.
	 */
	private double informationGain(String word, Map<Type, Integer> occurrences, Map<Type,Map<String, Integer>> wordsOccurrencesByType, boolean appears) {
		// Stores the information gain.
		double ig = 0;
		
		// Retrieves the total size of the set.
		// To do so, it iterates over all possible types
		// and sums the number of items of each type where
		// the word either appears or not appears.
		int size = 0;
		for (Type type : Type.values()) {
			// If some item of the specified type contains the word, 
			// then two things may happen: if the information gain is
			// for the appearing set, then the number of occurrences
			// is summed up. In the case the information gain is being
			// calculated for the non-appearing set, then the number of
			// occurrences is substracted from the total number of items
			// to obtain the non-occurrences.
			if (wordsOccurrencesByType.get(type).containsKey(word)) {
				size += appears? wordsOccurrencesByType.get(type).get(word) : occurrences.get(type) - wordsOccurrencesByType.get(type).get(word);
			// If no item of the specified type contains the word, 
			// then two things may happen: if the information gain is
			// for the appearing set, then nothing happens. In the case 
			// the information gain is being calculated for the 
			// non-appearing set, then the total number of items for
			// this type is summed up.
			} else {
				size += appears? 0 : occurrences.get(type);
			}
		}
	
		// Iterates over each possible type.
		for (Type type : Type.values()) {
			double hits;
			
			// Calculates how many items containing (or not containing, 
			// if the appears flag is set to false) the specified word
			// belong to the specific type.
			// This follows the same logic as when the total set size
			// was being calculated.
			if (wordsOccurrencesByType.get(type).containsKey(word)) {
				hits = appears? wordsOccurrencesByType.get(type).get(word) : occurrences.get(type) - wordsOccurrencesByType.get(type).get(word);
			} else {
				hits = appears? 0 : occurrences.get(type);
			}
			
			// Updates the value of the information gain with the entropy
			// of this type.
			ig += (hits == 0) ? 0 : -(hits / size) * Math.log(hits / size) / Math.log(2);
		}
		
		return ig;
	}

	/**
	 * <p>Calculates the information gain from the complete set of items.</p>
	 * <p>The information gain is calculated as I\(S\) = \sum_{t \in Types}
	 * {P\(S_t\)\log_{2}{P\(S_t\)}}, where P\(S_t\) means the probability that
	 * an item is of type <em>t</em> in the set <em>S</em>.</p>
	 * @param items the set of items.
	 * @return the information gain for the set of items.
	 */
	private double informationGain(Set<? extends TextItem> items) {
		// Stores the information gain.
		double ig = 0;
		
		// Retrieves the total size of the set.
		int size = items.size();
		
		// Iterates over each possible type.
		for (Type type : Type.values()) {
			double hits = 0;
			// Calculates how many items belong to the specific type.
			for (TextItem item : items) {
				if (item.getType() == type) {
					hits++;
				}
			}
			
			// Updates the value of the information gain with the entropy
			// of this type.
			ig += -(hits / size) * Math.log(hits / size) / Math.log(2);
		}

		return ig;
	}
}
